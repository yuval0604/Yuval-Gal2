#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <math.h>

// Calculate Euclidean distance between two points
double euclidean_distance(double *point1, double *point2, int dim) {
    double sum = 0.0;
    for (int i = 0; i < dim; i++) {
        double diff = point1[i] - point2[i];
        sum += diff * diff;
    }
    return sqrt(sum);
}

// Assign points to nearest centroids
void assign_points_to_clusters(double **points, double **centroids, int *cluster_assignments, 
                             int num_points, int k, int dim) {
    for (int i = 0; i < num_points; i++) {
        int closest_centroid = 0;
        double min_distance = euclidean_distance(points[i], centroids[0], dim);
        
        for (int j = 1; j < k; j++) {
            double dist = euclidean_distance(points[i], centroids[j], dim);
            if (dist < min_distance) {
                min_distance = dist;
                closest_centroid = j;
            }
        }
        cluster_assignments[i] = closest_centroid;
    }
}

// Update centroids positions
void update_centroids(double **points, double **centroids, int *cluster_assignments, 
                     int num_points, int k, int dim) {
    int *counts = (int *)calloc(k, sizeof(int));
    double **sums = (double **)malloc(k * sizeof(double *));
    
    if (!counts || !sums) {
        free(counts);
        if (sums) {
            free(sums);
        }
        PyErr_SetString(PyExc_MemoryError, "Failed to allocate memory");
        return;
    }
    
    for (int i = 0; i < k; i++) {
        sums[i] = (double *)calloc(dim, sizeof(double));
        if (!sums[i]) {
            for (int j = 0; j < i; j++) {
                free(sums[j]);
            }
            free(sums);
            free(counts);
            PyErr_SetString(PyExc_MemoryError, "Failed to allocate memory");
            return;
        }
    }

    // Calculate sums and counts
    for (int i = 0; i < num_points; i++) {
        int cluster = cluster_assignments[i];
        counts[cluster]++;
        for (int j = 0; j < dim; j++) {
            sums[cluster][j] += points[i][j];
        }
    }

    // Update centroids
    for (int i = 0; i < k; i++) {
        if (counts[i] > 0) {
            for (int j = 0; j < dim; j++) {
                centroids[i][j] = sums[i][j] / counts[i];
            }
        }
    }

    // Cleanup
    for (int i = 0; i < k; i++) {
        free(sums[i]);
    }
    free(sums);
    free(counts);
}

static PyObject* fit(PyObject* self, PyObject* args) {
    PyObject *centroids_obj, *points_obj;
    int k, max_iter;
    double eps;

    // Parse Python arguments
    if (!PyArg_ParseTuple(args, "OOiid", &centroids_obj, &points_obj, &k, &max_iter, &eps)) {
        return NULL;
    }

    // Get dimensions
    int num_points = PyList_Size(points_obj);
    int dim = PyList_Size(PyList_GetItem(points_obj, 0));

    // Allocate memory
    double **centroids = malloc(k * sizeof(double *));
    double **points = malloc(num_points * sizeof(double *));
    int *cluster_assignments = malloc(num_points * sizeof(int));

    if (!centroids || !points || !cluster_assignments) {
        PyErr_SetString(PyExc_MemoryError, "Failed to allocate memory");
        goto cleanup;
    }

    // Convert Python lists to C arrays
    for (int i = 0; i < k; i++) {
        centroids[i] = malloc(dim * sizeof(double));
        if (!centroids[i]) {
            PyErr_SetString(PyExc_MemoryError, "Failed to allocate memory");
            goto cleanup;
        }
        for (int j = 0; j < dim; j++) {
            centroids[i][j] = PyFloat_AsDouble(PyList_GetItem(PyList_GetItem(centroids_obj, i), j));
        }
    }

    for (int i = 0; i < num_points; i++) {
        points[i] = malloc(dim * sizeof(double));
        if (!points[i]) {
            PyErr_SetString(PyExc_MemoryError, "Failed to allocate memory");
            goto cleanup;
        }
        for (int j = 0; j < dim; j++) {
            points[i][j] = PyFloat_AsDouble(PyList_GetItem(PyList_GetItem(points_obj, i), j));
        }
    }

    // Main K-means loop
    for (int iter = 0; iter < max_iter; iter++) {
        double **prev_centroids = malloc(k * sizeof(double *));
        if (!prev_centroids) {
            PyErr_SetString(PyExc_MemoryError, "Failed to allocate memory");
            goto cleanup;
        }

        // Store current centroids
        for (int i = 0; i < k; i++) {
            prev_centroids[i] = malloc(dim * sizeof(double));
            if (!prev_centroids[i]) {
                for (int j = 0; j < i; j++) {
                    free(prev_centroids[j]);
                }
                free(prev_centroids);
                PyErr_SetString(PyExc_MemoryError, "Failed to allocate memory");
                goto cleanup;
            }
            for (int j = 0; j < dim; j++) {
                prev_centroids[i][j] = centroids[i][j];
            }
        }

        // Run iteration
        assign_points_to_clusters(points, centroids, cluster_assignments, num_points, k, dim);
        update_centroids(points, centroids, cluster_assignments, num_points, k, dim);

        // Check convergence
        int converged = 1;
        for (int i = 0; i < k && converged; i++) {
            if (euclidean_distance(prev_centroids[i], centroids[i], dim) >= eps) {
                converged = 0;
            }
        }

        // Free previous centroids
        for (int i = 0; i < k; i++) {
            free(prev_centroids[i]);
        }
        free(prev_centroids);

        if (converged) break;
    }

    // Convert results back to Python list
    PyObject *result = PyList_New(k);
    if (!result) {
        PyErr_SetString(PyExc_MemoryError, "Failed to allocate memory for result");
        goto cleanup;
    }

    for (int i = 0; i < k; i++) {
        PyObject *centroid = PyList_New(dim);
        if (!centroid) {
            Py_DECREF(result);
            PyErr_SetString(PyExc_MemoryError, "Failed to allocate memory for centroid");
            goto cleanup;
        }
        for (int j = 0; j < dim; j++) {
            PyList_SetItem(centroid, j, PyFloat_FromDouble(centroids[i][j]));
        }
        PyList_SetItem(result, i, centroid);
    }

    // Cleanup
    for (int i = 0; i < k; i++) {
        free(centroids[i]);
    }
    free(centroids);
    for (int i = 0; i < num_points; i++) {
        free(points[i]);
    }
    free(points);
    free(cluster_assignments);

    return result;

cleanup:
    if (centroids) {
        for (int i = 0; i < k; i++) {
            if (centroids[i]) free(centroids[i]);
        }
        free(centroids);
    }
    if (points) {
        for (int i = 0; i < num_points; i++) {
            if (points[i]) free(points[i]);
        }
        free(points);
    }
    if (cluster_assignments) free(cluster_assignments);
    return NULL;
}

static PyMethodDef kmeans_methods[] = {
    {"fit", fit, METH_VARARGS, 
     "Perform K-means clustering.\n\n"
     "Args:\n"
     "    centroids: Initial centroids\n"
     "    points: Data points\n"
     "    k: Number of clusters\n"
     "    max_iter: Maximum iterations\n"
     "    eps: Convergence threshold\n"
     "Returns:\n"
     "    List of final centroids"},
    {NULL, NULL, 0, NULL}
};

static struct PyModuleDef mykmeanssp_module = {
    PyModuleDef_HEAD_INIT,
    "mykmeanssp",
    "K-means clustering implementation in C",
    -1,
    kmeans_methods
};

PyMODINIT_FUNC PyInit_mykmeanssp(void) {
    return PyModule_Create(&mykmeanssp_module);
}
